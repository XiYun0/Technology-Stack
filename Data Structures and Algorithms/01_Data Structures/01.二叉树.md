首先刷二叉树！

## 递归

一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用递归来处理

## 二叉树

### 遍历二叉树

分别对应着Leecode144、94、145题

[[C语言教程]二叉树代码实现01](https://www.bilibili.com/video/BV1Qx411m7Lb)

[[C语言教程]二叉树代码实现02](https://www.bilibili.com/video/BV1Qx411m7jE)

https://www.bilibili.com/video/BV1oV411d7U5?from=search&seid=12813230570465246393

- 前序遍历	
  - 遍历顺序：根->左->右，根全走完就返回上一节点再判断	根->左->右	
- 中序遍历
  - 遍历顺序：左->根->右，左边`全部`走完了再走根，根全部走完了再走右边。
- 后续遍历
  - 遍历顺序：左->右->根

>前、中、后遍历：即根在前，根在中，根在后

#### 递归

```java
package com.loong.algorithm.binarytree;

/**
 * @Author 龙
 * @Verse 溪云初起日沉阁，山雨欲来风满楼。
 * @Date 2020/11/29 21:17
 */
public class BinaryTreeRecursion {

    //    前序遍历，根->左->右	，每次都是新的根。
    private static void preOrder1(Node root){
        if(root == null){
            return;
        }
        System.out.print(root.value);	// 打印此时根的值
        preOrder1(root.left);	// 到根的左边，再使用	根->左->右
        preOrder1(root.right);
    }

    // 	中序遍历, 	左->根->右	,	每次都想着到最左边
    private static void midOrder1(Node root){
        if(root == null){
            return;
        }
        midOrder1(root.left);
        System.out.print(root.value);
        midOrder1(root.right);
    }
    
    // 后序遍历
    private static void postOrder1(Node root){
        if(root == null){
            return;
        }
        postOrder1(root.left);
        postOrder1(root.right);
        System.out.print(root.value);

    }

    public static void main(String[] args) {
        // 创建节点，并赋予他们数据，此时他们没有连接
        Node nodeA = new Node("A");
        Node nodeB = new Node("B");
        Node nodeC = new Node("C");
        Node nodeD = new Node("D");
        Node nodeE = new Node("E");
        Node nodeF = new Node("F");
        Node nodeG = new Node("G");

        // 将节点连接起来，nodeA的左边指向nodeB
        nodeA.left = nodeB;
        nodeA.right = nodeC ;
        nodeB.left = nodeD;
        nodeB.right = nodeE ;
        nodeC.right = nodeF;
        nodeE.left = nodeG;

        // 上面是算法题中的二叉树结构，一般直接提供
        preOrder1(nodeA);
        System.out.println();   //  换行
        midOrder1(nodeA);
        System.out.println();
        postOrder1(nodeA);

    }

    private static class Node {
        public String value;
        public Node left;	//	指针指向左孩子
        public Node right;


        public Node(String value) {
            this.value = value;
        }
    }
}
```

#### 非递归——栈





## 二叉搜索树

>特性
>
>1、对于 BST 的每一个节点 `node`，左子树节点的值都比 `node` 的值要小，右子树节点的值都比 `node` 的值大。
>
>2、对于 BST 的每一个节点 `node`，它的左侧子树和右侧子树都是 BST。



## 红黑树





## B树

